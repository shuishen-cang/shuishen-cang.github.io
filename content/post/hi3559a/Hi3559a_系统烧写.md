---
title: "Hi3559a_系统烧写(二)"
date: 2020-12-17T09:25:21+08:00
draft: false
---

运行环境：

| 类型 | 参数 |
|:--------|:-------------|
| CPU | HI3559A |
| FLASH | 64G |
| 系统 | big-little |

# 一、地址划分

| uboot | kernel | rootfs | a53up | m7 | user |
|:--------|:-------------|:--------|:-------------|:--------|:-------------|
|1M|9M|96M|10M|1M||

目前的办卡采用EMMCFLASH作为存储器，其中主要存储的块如上表：uboot、kernel、rootfs、a53up、m7，其余的空间可以作为一个硬盘挂载在linux系统中，以便系统访问。

# 二、烧写脚本
可以采用脚本一键烧写，其脚本如下：
```python
import sys,os,shutil
import serial

IS_Biglittle    = True
WRITE_SYSTEM    = False
WRITE_M7_FG     = False
WRITE_A53UP_FG  = True

MMC_BLK_SIZE = 0x800
DDR_BLK_SIZE = 0x100000
DDR_AMP_START = 0x52000000
DDR_A53_START = 0x45000000
TFTP_DDR_ADDR = DDR_A53_START

############################## big-little ##############################3333
# A53UP     0x44000000
# SMP       Ox52000000

class class_downlinux_emmc(object):
    def __init__(self,blk_size):
        self.cmd_list = []

        self.emmc_curr_addr = 0
        self.a53up_size = 0
        self.m7_size = 0

    def write_enternet(self):
        self.cmd_list.append('setenv ipaddr 192.168.4.100')
        self.cmd_list.append('setenv netmask 255.255.255.0 ')
        self.cmd_list.append('setenv gatewayip 192.168.4.1')
        self.cmd_list.append('setenv serverip 192.168.4.1')
        self.cmd_list.append('setenv ethaddr 00:11:22:33:44:55')
        self.cmd_list.append('sa')

    def write_blk_emmc(self,size,name,isext4 = False, writecmd = True):
        if(writecmd == True):
            self.cmd_list.append('mw.b 0x%x 0xff 0x%x' %(TFTP_DDR_ADDR, size * DDR_BLK_SIZE))
            self.cmd_list.append('tftp 0x%x %s' %(TFTP_DDR_ADDR, name))
            self.cmd_list.append('mmc erase 0x%x 0x%x' %(self.emmc_curr_addr, size * MMC_BLK_SIZE))
            if(isext4):
                self.cmd_list.append('mmc write.ext4sp 0 0x%x 0x%x 0x%x\n' %(TFTP_DDR_ADDR, self.emmc_curr_addr, size * MMC_BLK_SIZE))   
            else:
                self.cmd_list.append('mmc write 0 0x%x 0x%x 0x%x\n' %(TFTP_DDR_ADDR, self.emmc_curr_addr, size * MMC_BLK_SIZE))     
        self.emmc_curr_addr += size * MMC_BLK_SIZE

    def write_uboot(self,size):
        self.uboot_size = size
        self.uboot_addr = self.emmc_curr_addr
        self.write_blk_emmc(size, 'u-boot-hi3559av100.bin',writecmd = WRITE_SYSTEM)

    def write_kernel(self,size):
        self.kernel_size = size     
        self.kernel_addr = self.emmc_curr_addr
        if(IS_Biglittle):
            self.write_blk_emmc(size, 'uImage_hi3559av100_big-little',writecmd = WRITE_SYSTEM)
        else:
            self.write_blk_emmc(size, 'uImage_hi3559av100_multi-core',writecmd = WRITE_SYSTEM)

    def write_rootfs(self,size):
        self.rootfs_size = size
        self.rootfs_addr = self.emmc_curr_addr
        self.write_blk_emmc(size, 'rootfs_hi3559av100_96M.ext4', isext4 = True, writecmd = WRITE_SYSTEM)

    def write_a53up(self,size):
        self.a53up_size = size
        self.a53up_addr = self.emmc_curr_addr
        self.write_blk_emmc(size, 'sample_a53',writecmd = WRITE_A53UP_FG)

    def write_m7(self,size):
        self.m7_size = size
        self.m7_addr = self.emmc_curr_addr
        self.write_blk_emmc(size, 'sample_m7',writecmd = WRITE_M7_FG)

    def write_cmd(self):
        m7_str = ''
        a53_str = ''
        if(self.a53up_size != 0):
            a53_str = 'mmc read 0 0x%x 0x%x 0x%x; go_a53up 0x%x;' % (DDR_A53_START, self.a53up_addr, self.a53up_size * MMC_BLK_SIZE, DDR_A53_START)
        if(self.m7_size != 0):
            m7_str = 'config_m7; mmc read 0 0x%x 0x%x 0x%x;cp.b 0x%x 0x19000000 0x%x; go_m7;' % (DDR_AMP_START, self.m7_addr, self.m7_size * MMC_BLK_SIZE, DDR_AMP_START, self.m7_size * DDR_BLK_SIZE)
        boot_str = 'mmc read 0 0x%x 0x%x 0x%x; bootm 0x%x' % (DDR_AMP_START, self.kernel_addr, self.kernel_size * MMC_BLK_SIZE, DDR_AMP_START)
        
        if(IS_Biglittle):
            self.cmd_list.append('setenv bootargs \'mem=512M console=ttyAMA0,115200 clk_ignore_unused rw init=/linuxrc rootwait ip=192.168.4.100:::::eth0 root=/dev/mmcblk0p3 rootfstype=ext4 blkdevparts=mmcblk0:%dM(uboot),%dM(kernel),%dM(rootfs),%dM(a53up),10M(M7),-(user)\''\
                % (self.uboot_size, self.kernel_size, self.rootfs_size, self.a53up_size))
        else:
            self.cmd_list.append('setenv bootargs \'mem=512M console=ttyAMA0,115200 clk_ignore_unused rw rootwait ip=192.168.4.100:::::eth0 root=/dev/mmcblk0p3 rootfstype=ext4 blkdevparts=mmcblk0:%dM(uboot),%dM(kernel),%dM(rootfs),%dM(a53up),10M(M7),-(user)\''\
                % (self.uboot_size, self.kernel_size, self.rootfs_size, self.a53up_size))   

        self.cmd_list.append('setenv bootcmd \'%s%s%s\'' % (m7_str, a53_str, boot_str))
        self.cmd_list.append('sa')

    ####################################### other ################################################

    def debug_a53(self,size):
        self.cmd_list.append('mw.b ' + hex(self.a53up_addr) + ' 0xff ' + hex(size * self.ddr_size))
        self.cmd_list.append('tftp ' + hex(self.a53up_addr) + ' sample.bin')
        self.cmd_list.append('go_a53up ' + hex(self.a53up_addr))

    def reset(self,ser):
        self.wait_printf('reset',ser,'autoboot')
        self.wait_printf('',ser,)

    def generate_cmd(self):
        self.cmd_text = ''

    def wait_printf(self,cmd,ser,ret_cmd = 'hisilicon #'):
        cmd += '\n'
        result=ser.write(cmd.encode())
        str = ''
        while True:
            m = ser.read(1).decode()
            str += m
            if ret_cmd in str:
                print(str)
                return

    def write_list(self,ser):
        for cmd in self.cmd_list:
            self.wait_printf(cmd,ser)
            # print(cmd)            

def main():
    emmc_test = class_downlinux_emmc(512)
    emmc_test.write_uboot(1)
    emmc_test.write_kernel(9)
    emmc_test.write_rootfs(96)
    emmc_test.write_a53up(10)
    emmc_test.write_m7(1)
    emmc_test.write_cmd()

    ser=serial.Serial('/dev/ttyUSB0',115200,timeout=0.5)
    emmc_test.write_list(ser)
        
    ser.close()

if __name__ == "__main__":
    main()
```

如上表所示：讲uboot、kernel、rootfs、a53的程序以及m7的程序防止tftpd服务器根目录下，用python运行该程序，便可以一键烧写系统程序。

# 三、A53UP烧写脚本
在docker中运行应用程序的开发，因此需要主机跟docker容器共享tftpd根目录，在a53up的应用程序中添加如下代码，讲生成的bin复制到tftpd服务器下：
```bash
# 在docker容器的makefie中
cp sample.bin /home/shuixia/workspace/01hi3559a/01tftproot/sample_a53
```

在主机中一直运行该部分代码，程序一直监控sample_a53是否有变化，一旦有变化，便启动烧录程序。
```python
#-*- encoding=utf8 -*-
import time
import serial
import os,sys,shutil
from create_download import *

mfile = '/home/shuixia/workspace/01hi3559a/01tftproot/sample_a53'
if_first = True
o_time = 0

def get_diff(file):
    global if_first
    global o_time
    if os.path.isfile(file):
        if(if_first == True):
            o_time = c_time = time.ctime(os.path.getatime(file));  
            if_first = False
        c_time = time.ctime(os.path.getatime(file))
        if(c_time != o_time):
            o_time = c_time
            return True
    return False

def debug_a53up():
    if(get_diff(mfile)):
        print("start download!")
        ser=serial.Serial('/dev/ttyUSB0',115200,timeout=0.5)
        emmc_test = class_downlinux_emmc(512)
        emmc_test.reset(ser)
        emmc_test.debug_a53(20)
        emmc_test.write_list(ser)
        ser.close()
        print("end download!")
        

def main():
    while True:
        time.sleep(1)
        debug_a53up()

if __name__ == "__main__":
    main()

```

