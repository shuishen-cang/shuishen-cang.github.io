<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hi3559a on 洛沧</title>
    <link>https://shuishen-cang.github.io/tags/hi3559a/</link>
    <description>Recent content in Hi3559a on 洛沧</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Dec 2020 16:57:05 +0800</lastBuildDate>
    
	<atom:link href="https://shuishen-cang.github.io/tags/hi3559a/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Hi3559a_开发(三)-A53调试：helloworld</title>
      <link>https://shuishen-cang.github.io/post/hi3559a/03hi3559a_a53up%E8%B0%83%E8%AF%951/</link>
      <pubDate>Fri, 25 Dec 2020 16:57:05 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/hi3559a/03hi3559a_a53up%E8%B0%83%E8%AF%951/</guid>
      <description>芯片的大核心采用linux系统，其异构方式为multicore。multicore默认是不启动liteos的，考虑到后期的具体应用，在multicore的前提上启动liteos，其中a53up的工程位于osdrv/platform/liteos_a53/liteos中(osdrv/platform/liteos_a53/liteos_user有问题)。
一、加载驱动 linux与liteos之间采用ipcm进行核间通信，测试通linux与liteos之间的核间通信便知道liteos已经正常启动。需要先设置网卡的ip地址。
# 在主机 sudo ifconfig enp4s0 192.168.4.1 插入串口线，插入网线，启动板卡进入linux系统，网卡灯正常闪烁，表示网络初始化正常。串口登录进linux系统，搭建nfs平台。
mkdir /home/00shell cd /home/00shell vi nfs.sh #添加 #!/bin/sh mount -t nfs -o nolock 192.168.4.1:/home/luocang/workspace /mnt # 根据个人目录设置 #end chmod +x nfs.sh ./nfs.sh 插入ipcm的驱动。
mkdir /home/01ko cd /home/01ko cp /mnt/04work/02hi3559a/02sdk/Hi3559AV100R001C02SPC020/01.software/board/Hi3559AV100_SDK_V2.0.2.0/osdrv/components/ipcm/ipcm/out/node_0/* ./ vi /etc/profile # 添加 insmod /home/01ko/hi_ipcm.ko insmod /home/01ko/hi_virt-tty.ko # end reboot lsmod 二、A53UP烧写程序 在docker中运行应用程序的开发，因此需要主机跟docker容器共享tftpd根目录，在a53up的应用程序中添加如下代码，将生成的bin复制到tftpd服务器下：
# 在docker容器a53up的makefie中 cp sample.bin /workspace/05tftpboot/sample_a53 编译成功后便会在在tftp根目录下生成一个sample_a53的文件 烧写程序可以采用之前提供的脚本进行程序烧写，但是此时仅需要更新用户程序，不烧写系统，因此需要稍做配置
IS_Biglittle = False WRITE_SYSTEM = False WRITE_M7_FG = False WRITE_A53UP_FG = True 然后串口控制台进入uboot，然后退出minicom，运行该脚本。</description>
    </item>
    
    <item>
      <title>Hi3559a_开发(四)-A53调试：中断分析</title>
      <link>https://shuishen-cang.github.io/post/hi3559a/04hi3559a_a53up%E8%B0%83%E8%AF%952/</link>
      <pubDate>Fri, 25 Dec 2020 16:57:05 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/hi3559a/04hi3559a_a53up%E8%B0%83%E8%AF%952/</guid>
      <description>一、 中断分析-linux部分 hi3559a的核心部署方式为multicore和big-little，在multicore方式中，所有跟媒体相关的代码都在linux系统，在big-little方式中，部分媒体相关的代码在liteos中，媒体代码与liteos存在较大的耦合。
在milticore方式中，所有的中断都指向了linux系统，在big-little方式中，部分中断指向了linux系统，另一部分中断指向了liteos。那么能不能在multicore方式中使中断指向liteos呢？
在linux系统中，通过对linux系统打海思官方提供的补丁得到海思的定制系统，其中中断部分的代码位于drivers/irqchip/路径，其中初始化位于irq-gic.c中，中断向量表位于irq-map-hi3559av100.h中。
其中初始化函数如下，该函数主要是将linux补丁中的中断向量表写入芯片配置：
static void gic_dist_init_amp(struct gic_chip_data *gic) { unsigned int i; u32 cpumask; unsigned int *irq_map_int = (unsigned int *)irq_map;	//这是中断向量表的位置 	unsigned int gic_irqs = gic-&amp;gt;gic_irqs; void __iomem *base = gic_data_dist_base(gic); writel_relaxed(GICD_DISABLE, base + GIC_DIST_CTRL); /* * Set all global interrupts to this CPU only. */ for (i = 32; i &amp;lt; gic_irqs; i += 4) { cpumask = irq_map_int[i / 4]; writel_relaxed(cpumask, base + GIC_DIST_TARGET + i * 4 / 4);	//设置中断向量表 	} gic_dist_config(base, gic_irqs, NULL); writel_relaxed(GICD_ENABLE, base + GIC_DIST_CTRL); } 其中big-little和multicore都存在该部分代码，但是在不同的方式下，有不同的效果，说明执行条件不一样，因此需要看该部分代码的执行条件。</description>
    </item>
    
    <item>
      <title>Hi3559a_开发(一)-系统编译</title>
      <link>https://shuishen-cang.github.io/post/hi3559a/01hi3559a_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 17 Dec 2020 10:23:59 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/hi3559a/01hi3559a_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</guid>
      <description>一、安装docker镜像 1. 导入docker镜像 由于之前已经搭建好了docker的运行环境，之前已经设置好了海思3559a的docker镜像，因此需要开启一个新的docker容器。 我的海思sdk、用户程序以及tftp服务器都放在/home/luocang/workspace/04work/02hi3559a/路径下面，因此需要将该目录共享到docker容器上面。
# 该docker镜像以ubuntu14.04为基础，安装了海思的必要的开发工具 docker run -it --name=cang -v /home/luocang/workspace/04work/02hi3559a:/workspace hisys /bin/bash # 已经进入了docker系统，退出 exit 2. 安装tftp服务器，以及nfs服务器 参考Ubuntu开发环境搭建
在安装好了tftp服务器后，需要配置tftp服务器的根目录路径
sudo vim /etc/default/tftpd-hpa # 修改为 TFTP_USERNAME=&amp;#34;tftp&amp;#34; TFTP_DIRECTORY=&amp;#34;/home/luocang/workspace/04work/02hi3559a/05tftpboot&amp;#34; TFTP_ADDRESS=&amp;#34;:69&amp;#34; TFTP_OPTIONS=&amp;#34;-l -c -s&amp;#34; # end sudo service tftpd-hpa restart 在安装好了nfs服务器后，需要配置nfs服务器的共享路径权限
sudo vim /etc/exports # 添加 /home/luocang/workspace/04work/02hi3559a *(rw,sync,no_subtree_check) # end sudo service nfs-server restart 二、系统编译 海思提供一键编译，编译好的文件包括uboot、内核、根文件系等，编译好的文件通过tftp下载到板卡中，因此需要讲输出文件拷贝到tftp根目录下面。
1. 解压 先进入sdk，并且对sdk进行解压。
docker start cang docker attach cang # 进入docker容器内部 cd /workspace/......./Hi3559AV100_SDK_V2.0.2.0/ ./sdk.cleanup ./sdk.unpack 文件已经解压到了sdk目录中，但是编译之前需要下载内核文件，我下载的内核放在sdk平行的目录中，因此在编译前需要将内核文件拷贝到kernel路径下。</description>
    </item>
    
    <item>
      <title>Hi3559a_开发(二)-系统烧写</title>
      <link>https://shuishen-cang.github.io/post/hi3559a/02hi3559a_%E7%B3%BB%E7%BB%9F%E7%83%A7%E5%86%99/</link>
      <pubDate>Thu, 17 Dec 2020 09:25:21 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/hi3559a/02hi3559a_%E7%B3%BB%E7%BB%9F%E7%83%A7%E5%86%99/</guid>
      <description>运行环境：
   类型 参数     CPU HI3559A   FLASH 64G   系统 big-little    一、地址划分    uboot kernel rootfs a53up m7 user     1M 9M 96M 10M 1M     目前的办卡采用EMMCFLASH作为存储器，其中主要存储的块如上表：uboot、kernel、rootfs、a53up、m7，其余的空间可以作为一个硬盘挂载在linux系统中，以便系统访问。
板卡默认的ip地址是192.168.4.100，主机的ip地址是192.168.4.1
sudo ifconfig enp4s0 192.168.4.1 二、烧写脚本 采用python脚本来进行程序烧写，需要先安装python3
sudo apt install python3 sudo apt install python3-pip pip3 install pyserial 烧写脚本： class_downlinux_emmc.py
import sys,os,shutil import serial IS_Biglittle = False WRITE_SYSTEM = True WRITE_M7_FG = False WRITE_A53UP_FG = False MMC_BLK_SIZE = 0x800 DDR_BLK_SIZE = 0x100000 DDR_AMP_START = 0x52000000 DDR_A53_START = 0x45000000 TFTP_DDR_ADDR = DDR_A53_START ############################## big-little ##############################3333 # A53UP 0x44000000 # SMP Ox52000000 class class_downlinux_emmc(object): def __init__(self,blk_size): self.</description>
    </item>
    
  </channel>
</rss>