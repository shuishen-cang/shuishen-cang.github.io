<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>洛沧</title>
    <link>https://shuishen-cang.github.io/</link>
    <description>Recent content on 洛沧</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 06 Jan 2021 00:02:20 +0800</lastBuildDate>
    
	<atom:link href="https://shuishen-cang.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Lichee_04驱动分析</title>
      <link>https://shuishen-cang.github.io/post/lichee/lichee_04%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Jan 2021 00:02:20 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/lichee/lichee_04%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</guid>
      <description>一、字符驱动 linux的驱动主要分为字符驱动、块驱动和网络驱动，字符驱动比较简单，容易上手。linux系统中一切皆是文件，驱动也不例外，用户程序在用户空间使用驱动主要是通过读写设备文件，并且对设备文件进行读写操作，因此实现驱动程序应该实现以下功能：
 在文件系统中创建一个可以访问的文件 建立起读写打开等函数的实现 将读写打开等函数与创建的文件联系起来  graph TD d4--&amp;gt;d5(class_create) d5--&amp;gt;d6(device_create) d5--&amp;gt;d7(device_create) subgraph register_chrdev d1(alloc_chrdev)--&amp;gt;d2(cdev_alloc)--&amp;gt;d3(cdev_init)--&amp;gt;d4(cdev_add) end 如上图所示：驱动程序的注册的流程如上图所示：由上述一系列函数组成，其中函数说明如下：
   函数 说明     alloc_chrdev 申请一组可用的主从设备号，当主设备号为零的时候表明是动态分配   cdev_alloc 申请一个可用的dev对象，用于存储操作函数相关的结构体   cdev_init 将操作函数结构体赋值   cdev_add 将cdev与主从设备号关联起来   class_create 在/sys/class/路径下面创建一个类用于存储驱动相关信息   device_create 在class_create创建的类下面创建一个device，分配唯一的主从设备号，并且uevent给udev在/dev下面创建软连接    tops.c
#include &amp;lt;linux/init.h&amp;gt;#include &amp;lt;linux/kernel.h&amp;gt;#include &amp;lt;linux/module.h&amp;gt;#include &amp;lt;linux/fs.h&amp;gt;#include &amp;lt;linux/cdev.h&amp;gt;#include &amp;lt;linux/slab.h&amp;gt;#include &amp;lt;linux/uaccess.h&amp;gt;#include &amp;lt;linux/semaphore.h&amp;gt;#include &amp;lt;linux/miscdevice.h&amp;gt;#include &amp;lt;linux/vmalloc.h&amp;gt;#include &amp;lt;linux/wait.h&amp;gt;#include &amp;lt;linux/poll.h&amp;gt;#include &amp;lt;linux/sched.h&amp;gt;#include &amp;lt;linux/proc_fs.h&amp;gt;#include &amp;lt;linux/seq_file.h&amp;gt;#include &amp;lt;linux/mutex.h&amp;gt;#include &amp;lt;linux/spinlock.h&amp;gt;#include &amp;lt;linux/timer.</description>
    </item>
    
    <item>
      <title>Lichee_03GPIO摸索</title>
      <link>https://shuishen-cang.github.io/post/lichee/lichee_03gpio%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Jan 2021 00:02:08 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/lichee/lichee_03gpio%E5%88%86%E6%9E%90/</guid>
      <description>一、设备树 linux使用设备树来管理device，我们之前使用的设备树是sun8i-v3s-licheepi-zero-dock.dts，根据设备树在板卡的/sys/firmware/devicetree/base会生成相对应的属性文件，板卡上存在一个三色的led，我们可以用它来测试驱动，但是该部分led在系统启动后便已经正常点亮，因此需要查看该部分原因。
经过分析，其中RGBled的引脚与MMC1的引脚发生了冲突，因此导致了LED上电之后会正常启动，那么应该禁止其在设备树中的使能。修改sun8i-v3s-licheepi-zero-dock.dts，删除其MMC1中的status = &amp;ldquo;okay&amp;rdquo;;代码如下：
&amp;amp;mmc1 { pinctrl-0 = &amp;lt;&amp;amp;mmc1_pins&amp;gt;; pinctrl-names = &amp;#34;default&amp;#34;; broken-cd; bus-width = &amp;lt;4&amp;gt;; vmmc-supply = &amp;lt;&amp;amp;reg_vcc3v3&amp;gt;; }; 修改后对设备树进行编译。 在linux根目录下：
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- dtbs 将编译后的arch/arm/boot/dts/sun8i-v3s-licheepi-zero-dock.dtb覆盖掉之前的dtb，然后重启板卡，发现led已经没有启动了，然后查看mmc1的状态。
cat /sys/firmware/devicetree/base/soc/mmc@01c10000/status disabled 表明mmc1已经关闭了。
二、操作GPIO 如图所示，PG0的编号为192，因此采用linux的标准操作尝试操作一下GPIO。
echo 192 &amp;gt; /sys/class/gpio/ ls /sys/class/gpio/ cd /sys/class/gpio/gpio192/ echo &amp;#34;out&amp;#34; &amp;gt; /sys/class/gpio/gpio192/direction echo 1 &amp;gt; /sys/class/gpio/gpio192/value echo 0 &amp;gt; /sys/class/gpio/gpio192/value 当给value赋值为0的时候发现灯能够点亮，赋值为1的时候灯熄灭，说明GPIO操作成功，依次尝试操作PG0，PG1，PG2都能成功，说明操作该部分GPIO成功。
三、编写用户程序测试GPIO 上面代码在shell实现了gpio的操作，但是大部分时候程序是在c语言中实现的，c语言中其gpio的翻转速度更快一些。
其实现步骤如下：
 往/sys/class/gpio/export写入引脚编号 设置引脚方向 写入引脚的值  代码如下：
hal_gpio.c
#include &amp;#34;hal_gpio.h&amp;#34; struct gpio_ctl pg_port[] = { { .</description>
    </item>
    
    <item>
      <title>Lichee_01开发环境</title>
      <link>https://shuishen-cang.github.io/post/lichee/lichee_01%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sun, 27 Dec 2020 21:31:22 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/lichee/lichee_01%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>一、开发环境搭建 1. 建立docker容器 手上有一块lichee板子很久了，lichee的资料相对较全，最近又在学习linux，因此拿这个平台验证一下也不错，要开发芯片，必须先搭建交叉编译环境，考虑到电脑上已经安装了一个树莓派的交叉编译环境了，那么就在docker里面安装交叉编译器吧。
先搭建一个最基本的docker开发环境吧，采用ubuntu18为基础
docker pull ubuntu:18.04 docker images 可以看到已经存在ubuntu镜像了，然后在workspace下面建立一个目录用来作为lichee的开发目录，其目录为~/workspace/02prj/01lichee_zero下面，因此采用以下命令创建一个容器。
docker run -it --name=lichee -v ~/workspace/02prj/01lichee_zero:/workspace ubuntu:18.04 /bin/bash # 进入docker容器后 apt update apt install nano nano /etc/apt/sources.list # 修改为 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.</description>
    </item>
    
    <item>
      <title>Lichee_02系统编译</title>
      <link>https://shuishen-cang.github.io/post/lichee/lichee_02%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/</link>
      <pubDate>Sun, 27 Dec 2020 21:31:22 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/lichee/lichee_02%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/</guid>
      <description>一、编译uboot 1. 下载uboot 主机和容器之间存在共享文件夹，在主机里下载最新的uboot。
cd ~/workspace/02prj/01lichee_zero/01system/ git clone https://github.com/Lichee-Pi/u-boot.git -b v3s-current 等待下载完毕后，进入u-boot路径，由于买的板子没有spiflash，因此需要编译支持SD卡启动，修改uboot，
# 修改 include/configs/sun8i.h, 使u-boot可以直接从tf卡启动： vim include/configs/sun8i.h # 添加 #define CONFIG_BOOTCOMMAND &amp;#34;setenv bootm_boot_mode sec; load mmc 0:1 0x41000000 zImage; load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-dock.dtb; bootz 0x41000000 - 0x41800000;&amp;#34; #define CONFIG_BOOTARGS &amp;#34;console=ttyS0,115200 panic=5 mtdparts=tf:1M(uboot),64k(dtb),4M(kernel),-(rootfs) rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0&amp;#34; 2. 编译 先安装必须的依赖库。
apt-get install libncurses5-dev apt-get install device-tree-compiler apt-get install python apt-get install bc docker start lichee docker attach lichee cd /workspace/01system/u-boot/ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_800x480LCD_defconfig make ARCH=arm menuconfig time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 2&amp;gt;&amp;amp;1 | tee build.</description>
    </item>
    
    <item>
      <title>Hi3559a_开发(七)-A53调试：定时器测试</title>
      <link>https://shuishen-cang.github.io/post/hi3559a/06hi3559a_07%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 25 Dec 2020 16:57:14 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/hi3559a/06hi3559a_07%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B5%8B%E8%AF%95/</guid>
      <description>一、建立工程 HI3559A总共存在16个定时器，主要实现定时计数功能，可以供操作系统用作系统时钟，也可以供应用程序用作定时和计数，其中主SOC存在12个定时器，M7部分存在4个定时器。 其具体配置参考《Hi3559A╱C V100 ultra-HD Mobile Camera SoC 用户指南.pdf》。
为了方便程序的管理，在git下新建一个分支用来做定时器测试。
git checkout -b test_timer 其测试部分代码如下： user_timer.c
#include &amp;#34;user_timer.h&amp;#34; #if TIM10IR_EN irqreturn_t timer10_isr(int a, void *arg){ static uint16_t counter = 0; if(++counter == 20){ counter = 0; dprintf(&amp;#34;timer 2s!\n&amp;#34;); } writel(1,TIM_INTCLR(Mytimer)); //清除中断向量  return IRQ_HANDLED; } #endif  void timer10_initial(void){ dprintf(&amp;#34;start initial timer10\n&amp;#34;); writel(300000,TIM_LOAD(Mytimer)); //10ms  // writel(0,SC_CTRL); //默认3M的计数器  writel((1 &amp;lt;&amp;lt; 7) | (1 &amp;lt;&amp;lt; 6) | (1 &amp;lt;&amp;lt; 5) | (1 &amp;lt;&amp;lt; 1),TIM_CN(Mytimer)); //周期计数，不分频 #if TIM10IR_EN  request_irq(NUM_HAL_INTERRUPT_TIMER10, timer10_isr, 0,&amp;#34;timer10_isr&amp;#34;,NULL); #endif } void timer_test(void){ timer10_initial(); } user_timer.</description>
    </item>
    
    <item>
      <title>Hi3559a_开发(三)-A53调试：helloworld</title>
      <link>https://shuishen-cang.github.io/post/hi3559a/03hi3559a_03a53up%E8%B0%83%E8%AF%951/</link>
      <pubDate>Fri, 25 Dec 2020 16:57:05 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/hi3559a/03hi3559a_03a53up%E8%B0%83%E8%AF%951/</guid>
      <description>芯片的大核心采用linux系统，其异构方式为multicore。multicore默认是不启动liteos的，考虑到后期的具体应用，在multicore的前提上启动liteos，其中a53up的工程位于osdrv/platform/liteos_a53/liteos中(osdrv/platform/liteos_a53/liteos_user有问题)。
一、加载驱动 linux与liteos之间采用ipcm进行核间通信，测试通linux与liteos之间的核间通信便知道liteos已经正常启动。需要先设置网卡的ip地址。
# 在主机 sudo ifconfig enp4s0 192.168.4.1 插入串口线，插入网线，启动板卡进入linux系统，网卡灯正常闪烁，表示网络初始化正常。串口登录进linux系统，搭建nfs平台。
mkdir /home/00shell cd /home/00shell vi nfs.sh #添加 #!/bin/sh mount -t nfs -o nolock 192.168.4.1:/home/luocang/workspace /mnt # 根据个人目录设置 #end chmod +x nfs.sh ./nfs.sh 插入ipcm的驱动。
mkdir /home/01ko cd /home/01ko cp /mnt/04work/02hi3559a/02sdk/Hi3559AV100R001C02SPC020/01.software/board/Hi3559AV100_SDK_V2.0.2.0/osdrv/components/ipcm/ipcm/out/node_0/* ./ vi /etc/profile # 添加 insmod /home/01ko/hi_ipcm.ko insmod /home/01ko/hi_virt-tty.ko # end reboot lsmod 二、A53UP烧写程序 在docker中运行应用程序的开发，因此需要主机跟docker容器共享tftpd根目录，在a53up的应用程序中添加如下代码，将生成的bin复制到tftpd服务器下：
# 在docker容器a53up的makefie中 cp sample.bin /workspace/05tftpboot/sample_a53 编译成功后便会在在tftp根目录下生成一个sample_a53的文件 烧写程序可以采用之前提供的脚本进行程序烧写，但是此时仅需要更新用户程序，不烧写系统，因此需要稍做配置
IS_Biglittle = False WRITE_SYSTEM = False WRITE_M7_FG = False WRITE_A53UP_FG = True 然后串口控制台进入uboot，然后退出minicom，运行该脚本。</description>
    </item>
    
    <item>
      <title>Hi3559a_开发(四)-A53调试：中断分析</title>
      <link>https://shuishen-cang.github.io/post/hi3559a/04hi3559a_04a53up%E8%B0%83%E8%AF%952/</link>
      <pubDate>Fri, 25 Dec 2020 16:57:05 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/hi3559a/04hi3559a_04a53up%E8%B0%83%E8%AF%952/</guid>
      <description>一、 中断分析-linux部分 hi3559a的核心部署方式为multicore和big-little，在multicore方式中，所有跟媒体相关的代码都在linux系统，在big-little方式中，部分媒体相关的代码在liteos中，媒体代码与liteos存在较大的耦合。
在milticore方式中，所有的中断都指向了linux系统，在big-little方式中，部分中断指向了linux系统，另一部分中断指向了liteos。那么能不能在multicore方式中使中断指向liteos呢？
在linux系统中，通过对linux系统打海思官方提供的补丁得到海思的定制系统，其中中断部分的代码位于drivers/irqchip/路径，其中初始化位于irq-gic.c中，中断向量表位于irq-map-hi3559av100.h中。
其中初始化函数如下，该函数主要是将linux补丁中的中断向量表写入芯片配置：
static void gic_dist_init_amp(struct gic_chip_data *gic) { unsigned int i; u32 cpumask; unsigned int *irq_map_int = (unsigned int *)irq_map;	//这是中断向量表的位置 	unsigned int gic_irqs = gic-&amp;gt;gic_irqs; void __iomem *base = gic_data_dist_base(gic); writel_relaxed(GICD_DISABLE, base + GIC_DIST_CTRL); /* * Set all global interrupts to this CPU only. */ for (i = 32; i &amp;lt; gic_irqs; i += 4) { cpumask = irq_map_int[i / 4]; writel_relaxed(cpumask, base + GIC_DIST_TARGET + i * 4 / 4);	//设置中断向量表 	} gic_dist_config(base, gic_irqs, NULL); writel_relaxed(GICD_ENABLE, base + GIC_DIST_CTRL); } 其中big-little和multicore都存在该部分代码，但是在不同的方式下，有不同的效果，说明执行条件不一样，因此需要看该部分代码的执行条件。</description>
    </item>
    
    <item>
      <title>Hi3559a_开发(六)-A53调试：串口通信</title>
      <link>https://shuishen-cang.github.io/post/hi3559a/05hi3559a_06%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Fri, 25 Dec 2020 16:49:14 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/hi3559a/05hi3559a_06%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</guid>
      <description>一、修改makefile 海思官方提供的makefile不能支持多个文件的编译以及多文件夹的编译，因此需要对makefile稍作修改以便支持多文件的编译，其修改后的文件如下：
LITEOSTOPDIR ?= ../.. SAMPLE_OUT = ./build include $(LITEOSTOPDIR)/config.mk RM = -rm -rf #LITEOS_BASELIB += -lipcmsg_single_liteos LITEOS_LIBDEPS := --start-group $(LITEOS_LIBDEP) --end-group LITEOS_CFLAGS += $(SINC) include user/user.mk SRCS += $(wildcard sample.c) OBJS := $(SRCS:.c=.o) all: chkbindir $(OBJS) ifneq ($(LITEOS_CPU_TYPE), arm926) ifneq ($(OUT)/lib/libipcm.a, $(wildcard $(OUT)/lib/libipcm.a)) echo &amp;#34;$(OUT)&amp;#34; cp -rf $(LITEOS_CPU_TYPE)/*.a $(OUT)/lib endif endif @$(LD) $(LITEOS_LDFLAGS) --gc-sections -Map=$(SAMPLE_OUT)/sample.map -o $(SAMPLE_OUT)/sample $(addprefix $(SAMPLE_OUT)/,$(notdir $(OBJS))) $(LITEOS_LIBDEPS) $(LITEOS_TABLES_LDFLAGS) @$(OBJCOPY) -O binary $(SAMPLE_OUT)/sample $(SAMPLE_OUT)/sample.bin cp $(SAMPLE_OUT)/sample.bin /workspace/05tftpboot/sample_a53 clean: @if test -d $(SAMPLE_OUT) ; \ 	then \ 	rm -rf $(SAMPLE_OUT) ; \ 	fi @rm /workspace/05tftpboot/sample_a53 test:chkbindir $(OBJS) @echo $(OBJS) $(OBJS): %.</description>
    </item>
    
    <item>
      <title>opencm3使用教程(一)</title>
      <link>https://shuishen-cang.github.io/post/stm32/opencm3_1/</link>
      <pubDate>Sat, 19 Dec 2020 11:14:37 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/stm32/opencm3_1/</guid>
      <description>一、下载opencm3 我的opencm3库的路径放在/home/luocang/workspace/01library/02STM32/路径下，在该目录下安装opencm3的库
cd /home/luocang/workspace/01library/02STM32/ git clone --recursive git@github.com:libopencm3/libopencm3-examples.git mv libopencm3-examples/ 01libopencm3-examples/ cd 01libopencm3-examples/libopencm3/ git reset --hard v0.8.0 cd ../ make -j12 编译完毕后可以在路径下看到编译的链接库，在examples可以看到例程编译后的可执行文件。
二、设置路径 三、编写Makefile </description>
    </item>
    
    <item>
      <title>Hi3559a_开发(一)-系统编译</title>
      <link>https://shuishen-cang.github.io/post/hi3559a/01hi3559a_01%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 17 Dec 2020 10:23:59 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/hi3559a/01hi3559a_01%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</guid>
      <description>一、安装docker镜像 1. 导入docker镜像 由于之前已经搭建好了docker的运行环境，之前已经设置好了海思3559a的docker镜像，因此需要开启一个新的docker容器。 我的海思sdk、用户程序以及tftp服务器都放在/home/luocang/workspace/04work/02hi3559a/路径下面，因此需要将该目录共享到docker容器上面。
# 该docker镜像以ubuntu14.04为基础，安装了海思的必要的开发工具 docker run -it --name=cang -v /home/luocang/workspace/04work/02hi3559a:/workspace hisys /bin/bash # 已经进入了docker系统，退出 exit 2. 安装tftp服务器，以及nfs服务器 参考Ubuntu开发环境搭建
在安装好了tftp服务器后，需要配置tftp服务器的根目录路径
sudo vim /etc/default/tftpd-hpa # 修改为 TFTP_USERNAME=&amp;#34;tftp&amp;#34; TFTP_DIRECTORY=&amp;#34;/home/luocang/workspace/04work/02hi3559a/05tftpboot&amp;#34; TFTP_ADDRESS=&amp;#34;:69&amp;#34; TFTP_OPTIONS=&amp;#34;-l -c -s&amp;#34; # end sudo service tftpd-hpa restart 在安装好了nfs服务器后，需要配置nfs服务器的共享路径权限
sudo vim /etc/exports # 添加 /home/luocang/workspace/04work/02hi3559a *(rw,sync,no_subtree_check) # end sudo service nfs-server restart 二、系统编译 海思提供一键编译，编译好的文件包括uboot、内核、根文件系等，编译好的文件通过tftp下载到板卡中，因此需要讲输出文件拷贝到tftp根目录下面。
1. 解压 先进入sdk，并且对sdk进行解压。
docker start cang docker attach cang # 进入docker容器内部 cd /workspace/......./Hi3559AV100_SDK_V2.0.2.0/ ./sdk.cleanup ./sdk.unpack 文件已经解压到了sdk目录中，但是编译之前需要下载内核文件，我下载的内核放在sdk平行的目录中，因此在编译前需要将内核文件拷贝到kernel路径下。</description>
    </item>
    
    <item>
      <title>Hi3559a_开发(二)-系统烧写</title>
      <link>https://shuishen-cang.github.io/post/hi3559a/02hi3559a_02%E7%B3%BB%E7%BB%9F%E7%83%A7%E5%86%99/</link>
      <pubDate>Thu, 17 Dec 2020 09:25:21 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/hi3559a/02hi3559a_02%E7%B3%BB%E7%BB%9F%E7%83%A7%E5%86%99/</guid>
      <description>运行环境：
   类型 参数     CPU HI3559A   FLASH 64G   系统 big-little    一、地址划分    uboot kernel rootfs a53up m7 user     1M 9M 96M 10M 1M     目前的办卡采用EMMCFLASH作为存储器，其中主要存储的块如上表：uboot、kernel、rootfs、a53up、m7，其余的空间可以作为一个硬盘挂载在linux系统中，以便系统访问。
板卡默认的ip地址是192.168.4.100，主机的ip地址是192.168.4.1
sudo ifconfig enp4s0 192.168.4.1 二、烧写脚本 采用python脚本来进行程序烧写，需要先安装python3
sudo apt install python3 sudo apt install python3-pip pip3 install pyserial 烧写脚本： class_downlinux_emmc.py
import sys,os,shutil import serial IS_Biglittle = False WRITE_SYSTEM = True WRITE_M7_FG = False WRITE_A53UP_FG = False MMC_BLK_SIZE = 0x800 DDR_BLK_SIZE = 0x100000 DDR_AMP_START = 0x52000000 DDR_A53_START = 0x45000000 TFTP_DDR_ADDR = DDR_A53_START ############################## big-little ##############################3333 # A53UP 0x44000000 # SMP Ox52000000 class class_downlinux_emmc(object): def __init__(self,blk_size): self.</description>
    </item>
    
    <item>
      <title>Ubuntu_01开发环境搭建</title>
      <link>https://shuishen-cang.github.io/post/ubuntu/ubuntu_01%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Tue, 15 Dec 2020 22:21:25 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/ubuntu/ubuntu_01%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>一、换源 二、安装软件 sudo apt install vim sudo apt install gcc sudo apt install openocd sudo apt install libusb sudo apt install git sudo apt install minicom git config --global user.email &amp;#34;335403241@qq.com&amp;#34; git config --global user.name &amp;#34;cang&amp;#34; 三、NFS 搭建NFS服务器环境，供ARM板挂载
安装 &amp;amp; 配置 sudo apt install nfs-kernel-server sudo vim /etc/exports # 添加： /home/luocang/workspace *(rw,sync,no_subtree_check) #重启nfs服务 sudo service nfs-kernel-server restart 测试 sudo mount -t nfs -o nolock 127.0.0.1:/home/luocang/workspace /mnt 脚本 #!/bin/sh  sudo apt install nfs-kernel-server echo &amp;#39;/home/luocang/workspace *(rw,sync,no_subtree_check)&amp;#39; &amp;gt;&amp;gt; cang.</description>
    </item>
    
    <item>
      <title>Ubuntu_02qt开发环境搭建</title>
      <link>https://shuishen-cang.github.io/post/ubuntu/ubuntu_02qt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Tue, 15 Dec 2020 22:21:25 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/ubuntu/ubuntu_02qt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>一、安装qt ​	考虑到后期在docker中安装交叉编译器，并且在docker镜像中编译qt，docker镜像暂不考虑带图形界面，因此需要在主机安装qtcreator，但是qtcreator必须支持命令编译，这样便可以在主机中设置编译docker镜像上的程序。
安装QT 下载一个稳定版本的qt软件，其格式为.run，直接运行该程序即可。安装的时候带源码安装，以便后期的交叉编译。
二、新建项目 ​	新建一个qt控制台项目，一切采用默认配置，其项目名称为qtest。修改其main.cpp。
#include &amp;lt;QCoreApplication&amp;gt;#include &amp;lt;QDebug&amp;gt; int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); qDebug() &amp;lt;&amp;lt; &amp;#34;hello!&amp;#34;; return a.exec(); } 编译，运行，在控制台上打印了hello。
三、命令编译 ​	先clean工程，查看qmake的目录，我的qmake路径为：/home/installed/Qt5.9.9/5.9.9/gcc_64/bin/qmake
​	控制台进入qtest工程下面。
cd ~/Desktop/qtest/ /home/installed/Qt5.9.9/5.9.9/gcc_64/bin/qmake &amp;#34;OBJECTS_DIR=build&amp;#34; qtest.pro make ls ./qtest ​	程序已经能够正常运行，说明具备基本的docker镜像下开发条件。</description>
    </item>
    
    <item>
      <title>Ubuntu_03交叉编译器</title>
      <link>https://shuishen-cang.github.io/post/ubuntu/ubuntu_03%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8/</link>
      <pubDate>Tue, 15 Dec 2020 22:21:25 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/ubuntu/ubuntu_03%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8/</guid>
      <description>一、安装交叉编译器 1. 安装 在linux下面安装交叉编译器用来编译ARM的程序，其中M系统采用arm-none-eabi-gcc，其中linux程序采用arm-linux-gnueabihf-gcc，可以采用apt的方式安装。
sudo apt install gcc-arm-none-eabi sudo apt install gcc-arm-linux-gnueabi arm-linux-gnueabihf-gcc -v arm-none-eabi-gcc -v 2. 配置 其中安装的交叉编译器并不能用来编译所有的芯片程序，大部分时候会受到库的影响和配置的影响。因此需要做出一定的修改，其关键参数如下：
--with-arch=armv7-a --with-fpu=vfpv3-d16 --with-float=hard --with-mode=thumb --disable-sjlj-exceptions --disable-werror --enable-multilib --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=arm-linux-gnueabihf --disable-werror : 设置警告不报错 --enable-multilib : 可以支持多芯片 这些都是默认的配置，可以做一些芯片来适应不同的芯片，如下：
arm-linux-gnueabihf-gcc -v -mfpu=vfpv4 -mfloat-abi=soft -march=armv7 -mtune=cortex-a7 -mcpu=cortex-a7 二、测试代码 ​</description>
    </item>
    
    <item>
      <title>树莓派环境搭建(一)</title>
      <link>https://shuishen-cang.github.io/post/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%80/</link>
      <pubDate>Tue, 15 Dec 2020 22:15:18 +0800</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%80/</guid>
      <description>NFS 工作环境：ubuntu20.04
一、搭建交叉编译器 git clone git://github.com/raspberrypi/tools.git cd tools cp -r arm-bcm2708 /home/installed/opt/ # 配置路径 sudo vim ~/.bashrc export PATH=$PATH:/home/installed/opt/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin #export PATH=$PATH:/home/installed/opt/arm-bcm2708/arm-bcm2708hardfp-linux-gnueabi/bin export CFLAGS_RASP=&amp;#34;-O2 -pipe -mcpu=arm1176jzf-s -mfpu=vfp -mfloat-abi=hard -w&amp;#34; # 安装32位兼容库 sudo apt install lib32ncurses6 lib32ncurses-dev # 测试 arm-linux-gnueabihf-gcc -v 二、安装系统 在win下面使用Win32DiskImager软件，将网上下载的镜像的镜像烧写到SD卡中。 1. 开机启动配置 树莓派的图形界面需要账户密码登录之后才能进去，这样不方便QT程序的运行，因此需要开启开机自动运行。
修改sudo nano /etc/systemd/system/getty.target.wants/getty@tty1.service # 修改 # ExecStart=-/sbin/agetty -o &amp;#39;-p -- \\u&amp;#39; --noclear %I $TERM ExecStart=-/sbin/agetty --autologin pi --noclear %I $TERM 2. 网络配置 传统的树莓派都是采用有线网络和无线网络进行宿主机和目标机之间的通信，树莓派最新的系统中自带了usbnet，可以进行宿主机与目标机通信，并且通过宿主机(ubuntu)的路由转发可以访问外网，进行软件更新，但是usbnet没有默认开启，需要在配置文件中开启。 开机自启后使用串口登录，进入系统。
cd /boot sudo nano cmdline.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://shuishen-cang.github.io/post/hi3559a/05hi3559a_05gpio%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/hi3559a/05hi3559a_05gpio%E6%B5%8B%E8%AF%95/</guid>
      <description>title: &amp;ldquo;Hi3559a_开发(五)-GPIO&amp;rdquo; date: 2020-12-25T16:49:14+08:00 draft: false tags: [&amp;ldquo;Hi3559a&amp;rdquo;]
一、概述 HI3559a拥有较多的GPIO，其中大部分GPIO都存在复用功能，当使用其他功能的时候需要设置复用功能，否则外设不能实现复用外设的功能，其中GPIO可以在linux和liteos中设置，其中linux中使用pinctrl统一管理，在liteos中使用寄存器设置，其设置寄存器的文件为《Hi3559AV100_PINOUT_CN.xlsx》。
如上退所示，通过设置一些寄存器便可以实现对GPIO引脚的第二功能进行配置，以及配置其GPIO输入输出方向。
二、 liteos操作 1. 基本操作 在liteos下提供基本的GPIO操作，但是不能提供复用功能设置，应该其只实现了基本的io操作。其驱动实现在osdrv/platform/liteos_a53/liteos/drivers/gpio下面实现。
static struct gpio_ops pl061_ops = { .setdir = pl061_setdir, .getdir = pl061_getdir, .readbit = pl061_readbit, .writebit = pl061_writebit }; 在lite下面新建分支test_gpio.
git checkout -b test_gpio 新建user_gpio.c
#include &amp;#34;user_gpio.h&amp;#34; static int gpio_fd; void user_gpio_initial(void){ gpio_fd = open(&amp;#34;/dev/gpio&amp;#34;, O_RDWR); if(gpio_fd &amp;lt; 0){ printf(&amp;#34;can&amp;#39;t open gpiochip\n&amp;#34;); } } void user_gpio_setdir(uint8_t group, uint8_t pin, uint8_t Pdir){ gpio_groupbit_info pin_str; pin_str.groupnumber = group; pin_str.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://shuishen-cang.github.io/post/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BA%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shuishen-cang.github.io/post/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BA%8C/</guid>
      <description> title: &amp;ldquo;树莓派环境搭建(二)&amp;rdquo; date: 2020-12-15T23:19:50+08:00 draft: false [toc]
一、关闭开机画面 关闭彩虹屏 sudo nano /boot/config.txt #添加 disable_splash=1 屏蔽开机滚动代码 sudo nano /boot/cmdline.txt #修改 #console=tty1 -&amp;gt; console=tty3 #添加 logo.nologo loglevel=3 console=serial0,115200 console=tty3 root=PARTUUID=e230fc76-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait modules-load=dwc2,g_ether logo.nologo loglevel=3 二、打开串口 树莓派对外只提供了一个串口serial0，但是该串口默认作为了控制台串口，在开机启动项中删除串口控制台
sudo vim /boot/cmdline.txt #删除 console=serial0，115200 console=tty3 root=PARTUUID=e230fc76-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait modules-load=dwc2,g_ether logo.nologo loglevel=3 </description>
    </item>
    
  </channel>
</rss>